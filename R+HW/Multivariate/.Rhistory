} else{
po.theta1 <- c(po.theta1, po.theta1[i])
po.theta2 <- c(po.theta2, po.theta2[i])
}
}
m = 5000
rho = 0.99
cov_mtx <- matrix(c(1, rho, rho, 1), nrow = 2)
d = 1 #d는 적절한 합격률이 되도록 해야 함.
po.theta1 = NULL
po.theta2 = NULL
theta1 = 0
theta2 = 0
po.theta1 = c(po.theta1, theta1)
po.theta2 = c(po.theta2, theta2)
set.seed(42)
for (i in 1:m) {#m = 5000회 동안 반복.
proposal_theta1 <- rnorm(1, po.theta1[i], d)
proposal_theta2 <- rcauchy(1, location = 0, scale = 1) #제안분포에서 난수 생성
u <- runif(1, min = 0, max = 1) #합격-불합격 판정용 난수 생성
accp_prob <- min(1, (dmvnorm(c(po.theta1[i], po.theta2[i]), c(0, 0), cov_mtx)*dcauchy(po.theta2[i], 0, 1))/(dmvnorm(c(proposal_theta1, proposal_theta2), c(0, 0), cov_mtx)*dcauchy(proposal_theta2, 0, 1)))
if(accp_prob >= u){
po.theta1 <- c(po.theta1, proposal_theta1)
po.theta2 <- c(po.theta2, proposal_theta2)
} else{
po.theta1 <- c(po.theta1, po.theta1[i])
po.theta2 <- c(po.theta2, po.theta2[i])
}
}
set.seed(42)
for (i in 1:m) {#m = 5000회 동안 반복.
proposal_theta1 <- rnorm(1, po.theta1[i], d)
proposal_theta2 <- rcauchy(1, location = 0, scale = 1) #제안분포에서 난수 생성
u <- runif(1, min = 0, max = 1) #합격-불합격 판정용 난수 생성
accp_prob <- min(1, (dmvnorm(c(po.theta1[i], po.theta2[i]), c(0, 0), cov_mtx)*dcauchy(po.theta2[i], 0, 1))/(dmvnorm(c(proposal_theta1, proposal_theta2), c(0, 0), cov_mtx)*dcauchy(proposal_theta2, 0, 1)))
if(accp_prob >= u){
po.theta1 <- c(po.theta1, proposal_theta1)
po.theta2 <- c(po.theta2, proposal_theta2)
} else{
po.theta1 <- c(po.theta1, po.theta1[i])
po.theta2 <- c(po.theta2, po.theta2[i])
}
}
m = 5000
rho = 0.99
cov_mtx <- matrix(c(1, rho, rho, 1), nrow = 2)
d = 1 #d는 적절한 합격률이 되도록 해야 함.
po.theta1 = NULL
po.theta2 = NULL
theta1 = 0
theta2 = 0
po.theta1 = c(po.theta1, theta1)
po.theta2 = c(po.theta2, theta2)
set.seed(42)
for (i in 1:m) {#m = 5000회 동안 반복.
proposal_theta1 <- rnorm(1, po.theta1[i], d)
proposal_theta2 <- rcauchy(1, location = 0, scale = 1) #제안분포에서 난수 생성
u <- runif(1, min = 0, max = 1) #합격-불합격 판정용 난수 생성
accp_prob <- min(1, (dmvnorm(c(po.theta1[i], po.theta2[i]), c(0, 0), cov_mtx)*dcauchy(po.theta2[i], 0, 1))/(dmvnorm(c(proposal_theta1, proposal_theta2), c(0, 0), cov_mtx)*dcauchy(proposal_theta2, 0, 1)))
if(accp_prob >= u){
po.theta1 <- c(po.theta1, proposal_theta1)
po.theta2 <- c(po.theta2, proposal_theta2)
} else{
po.theta1 <- c(po.theta1, po.theta1[i])
po.theta2 <- c(po.theta2, po.theta2[i])
}
}
m = 5000
rho = 0.99
cov_mtx <- matrix(c(1, rho, rho, 1), nrow = 2)
d = 1 #d는 적절한 합격률이 되도록 해야 함.
po.theta1 = NULL
po.theta2 = NULL
theta1 = 0
theta2 = 0
po.theta1 = c(po.theta1, theta1)
po.theta2 = c(po.theta2, theta2)
set.seed(42)
for (i in 1:m) {#m = 5000회 동안 반복.
proposal_theta1 <- rnorm(1, po.theta1[i], d)
proposal_theta2 <- rcauchy(1, location = 0, scale = 1) #제안분포에서 난수 생성
u <- runif(1, min = 0, max = 1) #합격-불합격 판정용 난수 생성
accp_prob <- min(1, (dmvnorm(c(po.theta1[i], po.theta2[i]), c(0, 0), cov_mtx)*dcauchy(po.theta2[i], 0, 1))/(dmvnorm(c(proposal_theta1, proposal_theta2), c(0, 0), cov_mtx)*dcauchy(proposal_theta2, 0, 1)))
if(accp_prob >= u){
po.theta1 <- c(po.theta1, proposal_theta1)
po.theta2 <- c(po.theta2, proposal_theta2)
} else{
po.theta1 <- c(po.theta1, po.theta1[i])
po.theta2 <- c(po.theta2, po.theta2[i])
}
}
m = 5000
rho = 0.99
cov_mtx <- matrix(c(1, rho, rho, 1), nrow = 2)
d = 1 #d는 적절한 합격률이 되도록 해야 함.
po.theta1 = NULL
po.theta2 = NULL
theta1 = 0
theta2 = 0
po.theta1 = c(po.theta1, theta1)
po.theta2 = c(po.theta2, theta2)
set.seed(42)
for (i in 1:m) {#m = 5000회 동안 반복.
proposal_theta1 <- rnorm(1, po.theta1[i], d)
proposal_theta2 <- rcauchy(1, location = 0, scale = 1) #제안분포에서 난수 생성
u <- runif(1, min = 0, max = 1) #합격-불합격 판정용 난수 생성
accp_prob <- min(1, (dmvnorm(c(proposal_theta1, proposal_theta2), c(0, 0), cov_mtx)*dcauchy(po.theta2[i], 0, 1))/(dmvnorm(c(po.theta1[i], po.theta2[i]), c(0, 0), cov_mtx)*dcauchy(proposal_theta2, 0, 1)))
if(accp_prob >= u){
po.theta1 <- c(po.theta1, proposal_theta1)
po.theta2 <- c(po.theta2, proposal_theta2)
} else{
po.theta1 <- c(po.theta1, po.theta1[i])
po.theta2 <- c(po.theta2, po.theta2[i])
}
}
head(po.theta1)
head(po.theta2)
m = 500
rho = 0.99
cov_mtx <- matrix(c(1, rho, rho, 1), nrow = 2)
d = 0.1 #d는 적절한 합격률이 되도록 해야 함.
accepted = 0
po.theta1 = NULL
po.theta2 = NULL
theta1 = 0
theta2 = 0
po.theta1 = c(po.theta1, theta1)
po.theta2 = c(po.theta2, theta2)
set.seed(31)
for (i in 1:m) {#m = 5000회 동안 반복.
proposal_theta1 <- rnorm(1, po.theta1[i], d)
proposal_theta2 <- rcauchy(1, location = 0, scale = 1) #제안분포에서 난수 생성
u <- runif(1, min = 0, max = 1) #합격-불합격 판정용 난수 생성
accp_prob <- min(1, (dmvnorm(c(proposal_theta1, proposal_theta2), c(0, 0), cov_mtx)*dcauchy(po.theta2[i], 0, 1))/(dmvnorm(c(po.theta1[i], po.theta2[i]), c(0, 0), cov_mtx)*dcauchy(proposal_theta2, 0, 1)))
if(accp_prob >= u){
accepted <- accepted + 1
po.theta1 <- c(po.theta1, proposal_theta1)
po.theta2 <- c(po.theta2, proposal_theta2)
} else{
po.theta1 <- c(po.theta1, po.theta1[i])
po.theta2 <- c(po.theta2, po.theta2[i])
}
}
accepted/500
m = 5000
rho = 0.99
cov_mtx <- matrix(c(1, rho, rho, 1), nrow = 2)
d = 1 #d는 적절한 합격률이 되도록 해야 함.
po.theta1 = NULL
po.theta2 = NULL
theta1 = 0
theta2 = 0
po.theta1 = c(po.theta1, theta1)
po.theta2 = c(po.theta2, theta2)
set.seed(42)
for (i in 1:m) {#m = 5000회 동안 반복.
proposal_theta1 <- rnorm(1, po.theta1[i], d)
proposal_theta2 <- rcauchy(1, location = 0, scale = 1) #제안분포에서 난수 생성
u <- runif(1, min = 0, max = 1) #합격-불합격 판정용 난수 생성
accp_prob <- min(1, (dmvnorm(c(proposal_theta1, proposal_theta2), c(0, 0), cov_mtx)*dcauchy(po.theta2[i], 0, 1))/(dmvnorm(c(po.theta1[i], po.theta2[i]), c(0, 0), cov_mtx)*dcauchy(proposal_theta2, 0, 1)))
if(accp_prob >= u){
po.theta1 <- c(po.theta1, proposal_theta1)
po.theta2 <- c(po.theta2, proposal_theta2)
} else{
po.theta1 <- c(po.theta1, po.theta1[i])
po.theta2 <- c(po.theta2, po.theta2[i])
}
}
head(po.theta1)
head(po.theta2)
m = 500
rho = 0.99
cov_mtx <- matrix(c(1, rho, rho, 1), nrow = 2)
d = 0.1 #d는 적절한 합격률이 되도록 해야 함.
accepted = 0
po.theta1 = NULL
po.theta2 = NULL
theta1 = 0
theta2 = 0
po.theta1 = c(po.theta1, theta1)
po.theta2 = c(po.theta2, theta2)
set.seed(31)
for (i in 1:m) {#m = 5000회 동안 반복.
proposal_theta1 <- rnorm(1, po.theta1[i], d)
proposal_theta2 <- rcauchy(1, location = 0, scale = 1) #제안분포에서 난수 생성
u <- runif(1, min = 0, max = 1) #합격-불합격 판정용 난수 생성
accp_prob <- min(1, (dmvnorm(c(proposal_theta1, proposal_theta2), c(0, 0), cov_mtx)*dcauchy(po.theta2[i], 0, 1))/(dmvnorm(c(po.theta1[i], po.theta2[i]), c(0, 0), cov_mtx)*dcauchy(proposal_theta2, 0, 1)))
if(accp_prob >= u){
accepted <- accepted + 1
po.theta1 <- c(po.theta1, proposal_theta1)
po.theta2 <- c(po.theta2, proposal_theta2)
} else{
po.theta1 <- c(po.theta1, po.theta1[i])
po.theta2 <- c(po.theta2, po.theta2[i])
}
}
accepted/500
m = 500
rho = 0.3
cov_mtx <- matrix(c(1, rho, rho, 1), nrow = 2)
d = 3 #d는 적절한 합격률이 되도록 해야 함.
accepted = 0
po.theta1 = NULL
po.theta2 = NULL
theta1 = 0
theta2 = 0
po.theta1 = c(po.theta1, theta1)
po.theta2 = c(po.theta2, theta2)
set.seed(31)
for (i in 1:m) {#m = 5000회 동안 반복.
proposal_theta1 <- rnorm(1, po.theta1[i], d)
proposal_theta2 <- rcauchy(1, location = 0, scale = 1) #제안분포에서 난수 생성
u <- runif(1, min = 0, max = 1) #합격-불합격 판정용 난수 생성
accp_prob <- min(1, (dmvnorm(c(proposal_theta1, proposal_theta2), c(0, 0), cov_mtx)*dcauchy(po.theta2[i], 0, 1))/(dmvnorm(c(po.theta1[i], po.theta2[i]), c(0, 0), cov_mtx)*dcauchy(proposal_theta2, 0, 1)))
if(accp_prob >= u){
accepted <- accepted + 1
po.theta1 <- c(po.theta1, proposal_theta1)
po.theta2 <- c(po.theta2, proposal_theta2)
} else{
po.theta1 <- c(po.theta1, po.theta1[i])
po.theta2 <- c(po.theta2, po.theta2[i])
}
}
accepted/500
m = 5000
rho = 0.99
cov_mtx <- matrix(c(1, rho, rho, 1), nrow = 2)
d = 0.1
po.theta1 = NULL
po.theta2 = NULL
theta1 = 0
theta2 = 0
po.theta1 = c(po.theta1, theta1)
po.theta2 = c(po.theta2, theta2)
set.seed(42)
for (i in 1:m) {#m = 5000회 동안 반복.
proposal_theta1 <- rnorm(1, po.theta1[i], d)
proposal_theta2 <- rcauchy(1, location = 0, scale = 1) #제안분포에서 난수 생성
u <- runif(1, min = 0, max = 1) #합격-불합격 판정용 난수 생성
accp_prob <- min(1, (dmvnorm(c(proposal_theta1, proposal_theta2), c(0, 0), cov_mtx)*dcauchy(po.theta2[i], 0, 1))/(dmvnorm(c(po.theta1[i], po.theta2[i]), c(0, 0), cov_mtx)*dcauchy(proposal_theta2, 0, 1)))
if(accp_prob >= u){
po.theta1 <- c(po.theta1, proposal_theta1)
po.theta2 <- c(po.theta2, proposal_theta2)
} else{
po.theta1 <- c(po.theta1, po.theta1[i])
po.theta2 <- c(po.theta2, po.theta2[i])
}
}
post_1399 <- data.frame(theta1 = po.theta1, theta2 = po.theta2)
post_1399 %>% mcmc %>% ggs %>% ggs_histogram()
post_1399 %>% mcmc %>% ggs %>% ggs_density()
post_1399 %>% mcmc %>% ggs %>% ggs_traceplot()
post_1399 %>% mcmc %>% ggs %>% ggs_autocorrelation()
m = 5000
rho = 0.3
cov_mtx <- matrix(c(1, rho, rho, 1), nrow = 2)
d = 0.1
po.theta1 = NULL
po.theta2 = NULL
theta1 = 0
theta2 = 0
po.theta1 = c(po.theta1, theta1)
po.theta2 = c(po.theta2, theta2)
set.seed(42)
for (i in 1:m) {#m = 5000회 동안 반복.
proposal_theta1 <- rnorm(1, po.theta1[i], d)
proposal_theta2 <- rcauchy(1, location = 0, scale = 1) #제안분포에서 난수 생성
u <- runif(1, min = 0, max = 1) #합격-불합격 판정용 난수 생성
accp_prob <- min(1, (dmvnorm(c(proposal_theta1, proposal_theta2), c(0, 0), cov_mtx)*dcauchy(po.theta2[i], 0, 1))/(dmvnorm(c(po.theta1[i], po.theta2[i]), c(0, 0), cov_mtx)*dcauchy(proposal_theta2, 0, 1)))
if(accp_prob >= u){
po.theta1 <- c(po.theta1, proposal_theta1)
po.theta2 <- c(po.theta2, proposal_theta2)
} else{
po.theta1 <- c(po.theta1, po.theta1[i])
po.theta2 <- c(po.theta2, po.theta2[i])
}
}
post_1303 <- data.frame(theta1 = po.theta1, theta2 = po.theta2)
post_1303 %>% mcmc %>% ggs %>% ggs_histogram()
post_1303 %>% mcmc %>% ggs %>% ggs_density()
post_1303 %>% mcmc %>% ggs %>% ggs_traceplot()
post_1303 %>% mcmc %>% ggs %>% ggs_autocorrelation()
m = 50000
rho = 0.3
cov_mtx <- matrix(c(1, rho, rho, 1), nrow = 2)
d = 0.1
po.theta1 = NULL
po.theta2 = NULL
theta1 = 0
theta2 = 0
po.theta1 = c(po.theta1, theta1)
po.theta2 = c(po.theta2, theta2)
set.seed(42)
for (i in 1:m) {#m = 5000회 동안 반복.
proposal_theta1 <- rnorm(1, po.theta1[i], d)
proposal_theta2 <- rcauchy(1, location = 0, scale = 1) #제안분포에서 난수 생성
u <- runif(1, min = 0, max = 1) #합격-불합격 판정용 난수 생성
accp_prob <- min(1, (dmvnorm(c(proposal_theta1, proposal_theta2), c(0, 0), cov_mtx)*dcauchy(po.theta2[i], 0, 1))/(dmvnorm(c(po.theta1[i], po.theta2[i]), c(0, 0), cov_mtx)*dcauchy(proposal_theta2, 0, 1)))
if(accp_prob >= u){
po.theta1 <- c(po.theta1, proposal_theta1)
po.theta2 <- c(po.theta2, proposal_theta2)
} else{
po.theta1 <- c(po.theta1, po.theta1[i])
po.theta2 <- c(po.theta2, po.theta2[i])
}
}
post_1303 <- data.frame(theta1 = po.theta1, theta2 = po.theta2)
post_1303 %>% mcmc %>% ggs %>% ggs_histogram()
post_1303 %>% mcmc %>% ggs %>% ggs_density()
post_1303 %>% mcmc %>% ggs %>% ggs_traceplot()
post_1303 %>% mcmc %>% ggs %>% ggs_autocorrelation()
m = 5000
rho = 0.3
cov_mtx <- matrix(c(1, rho, rho, 1), nrow = 2)
d = 0.1
po.theta1 = NULL
po.theta2 = NULL
theta1 = 0
theta2 = 0
po.theta1 = c(po.theta1, theta1)
po.theta2 = c(po.theta2, theta2)
set.seed(42)
for (i in 1:m) {#m = 5000회 동안 반복.
proposal_theta1 <- rnorm(1, po.theta1[i], d)
proposal_theta2 <- rcauchy(1, location = 0, scale = 1) #제안분포에서 난수 생성
u <- runif(1, min = 0, max = 1) #합격-불합격 판정용 난수 생성
accp_prob <- min(1, (dmvnorm(c(proposal_theta1, proposal_theta2), c(0, 0), cov_mtx)*dcauchy(po.theta2[i], 0, 1))/(dmvnorm(c(po.theta1[i], po.theta2[i]), c(0, 0), cov_mtx)*dcauchy(proposal_theta2, 0, 1)))
if(accp_prob >= u){
po.theta1 <- c(po.theta1, proposal_theta1)
po.theta2 <- c(po.theta2, proposal_theta2)
} else{
po.theta1 <- c(po.theta1, po.theta1[i])
po.theta2 <- c(po.theta2, po.theta2[i])
}
}
post_1303 <- data.frame(theta1 = po.theta1, theta2 = po.theta2)
post_1303 %>% mcmc %>% ggs %>% ggs_histogram()
post_1303 %>% mcmc %>% ggs %>% ggs_density()
post_1303 %>% mcmc %>% ggs %>% ggs_traceplot()
post_1303 %>% mcmc %>% ggs %>% ggs_autocorrelation()
post_1303 %>% mcmc %>% summary
post_1399 %>% mcmc %>% summary
#가능도
df <- c(68.3, 85.7, 73.8, 83.2, 58.9, 72.7, 70.5, 58.7, 74.1, 75.0)
n <- len(df)
df
len(df)
length(df)
df <- c(68.3, 85.7, 73.8, 83.2, 58.9, 72.7, 70.5, 58.7, 74.1, 75.0) #가능도
m <- 5000
nu <- 20 #prior의 정보 1
theta0 <- 0 #prior의 정보 2
nu0 <- 1 #prior의 정보 3
s02 <- 1 #prior의 정보 4
theta_0 <- 0
delta_0 <- 1
ksi_0 <- 0
po.theta = NULL
po.delta = NULL
po.ksi = NULL
po.theta <- c(po.theta, theta_0)
po.delta <- c(po.delta, delta_0)
po.ksi <- c(po.ksi, ksi_0)
set.seed(42)
for (i in 1:m) {
ksi_prime <- rgamma(1, (1+nu)/2, rate = 1 + ((po.theta[i]-theta0)^2) / (nu*po.delta[i]))
theta_prime <- rnorm(1, (nu*mean(df) + 2*theta0*ksi_prime) / (nu+2*ksi_prime), sqrt((nu*po.delta[i]) / (nu+2*ksi_prime)))
delta_rate = (((nu + 2*ksi_prime)*((theta_prime - (nu*mean(df) + 2*ksi_prime*theta0) / (nu + 2*ksi_prime))^2))/(2*nu))+(1/2)*(nu0*s02+(length(df)-1)*var(df)+(2*ksi_prime*(mean(df)-theta0)^2)/(nu+2*ksi_prime))
delta_prime <- rinvgamma(1, (nu0 + n + 1)/2, rate = delta_rate)
po.theta <- c(po.theta, theta_prime)
po.delta <- c(po.delta, delta_prime)
po.ksi <- c(po.ksi, ksi_prime)
}
set.seed(42)
for (i in 1:m) {
ksi_prime <- rgamma(1, (1+nu)/2, rate = 1 + ((po.theta[i]-theta0)^2) / (nu*po.delta[i]))
theta_prime <- rnorm(1, (nu*mean(df) + 2*theta0*ksi_prime) / (nu+2*ksi_prime), sqrt((nu*po.delta[i]) / (nu+2*ksi_prime)))
delta_rate = (((nu + 2*ksi_prime)*((theta_prime - (nu*mean(df) + 2*ksi_prime*theta0) / (nu + 2*ksi_prime))^2))/(2*nu))+(1/2)*(nu0*s02+(length(df)-1)*var(df)+(2*ksi_prime*(mean(df)-theta0)^2)/(nu+2*ksi_prime))
delta_prime <- rinvgamma(1, (nu0 + length(df) + 1)/2, rate = delta_rate)
po.theta <- c(po.theta, theta_prime)
po.delta <- c(po.delta, delta_prime)
po.ksi <- c(po.ksi, ksi_prime)
}
post_3 <- data.frame(theta = po.theta, delta = po.delta)
View(post_3)
df <- c(68.3, 85.7, 73.8, 83.2, 58.9, 72.7, 70.5, 58.7, 74.1, 75.0) #가능도
m <- 5000
nu <- 20 #prior의 정보 1
theta0 <- 0 #prior의 정보 2
nu0 <- 1 #prior의 정보 3
s02 <- 1 #prior의 정보 4
theta_0 <- 0
delta_0 <- 1
ksi_0 <- 0
po.theta = NULL
po.delta = NULL
po.ksi = NULL
po.theta <- c(po.theta, theta_0)
po.delta <- c(po.delta, delta_0)
po.ksi <- c(po.ksi, ksi_0)
set.seed(42)
for (i in 1:m) {
ksi_prime <- rgamma(1, (1+nu)/2, rate = 1 + ((po.theta[i]-theta0)^2) / (nu*po.delta[i]))
theta_prime <- rnorm(1, (nu*mean(df) + 2*theta0*ksi_prime) / (nu+2*ksi_prime), sqrt((nu*po.delta[i]) / (nu+2*ksi_prime)))
delta_rate = (((nu + 2*ksi_prime)*((theta_prime - (nu*mean(df) + 2*ksi_prime*theta0) / (nu + 2*ksi_prime))^2))/(2*nu))+(1/2)*(nu0*s02+(length(df)-1)*var(df)+(2*ksi_prime*(mean(df)-theta0)^2)/(nu+2*ksi_prime))
delta_prime <- rinvgamma(1, (nu0 + length(df) + 1)/2, rate = delta_rate)
po.theta <- c(po.theta, theta_prime)
po.delta <- c(po.delta, delta_prime)
po.ksi <- c(po.ksi, ksi_prime)
}
#가능도
df <- c(68.3, 85.7, 73.8, 83.2, 58.9, 72.7, 70.5, 58.7, 74.1, 75.0)
m <- 5000
nu <- 20 #prior의 정보 1
theta0 <- 0 #prior의 정보 2
nu0 <- 1 #prior의 정보 3
s02 <- 1 #prior의 정보 4
theta_0 <- 0
delta_0 <- 1
ksi_0 <- 0
po.theta = NULL
po.delta = NULL
po.ksi = NULL
po.theta <- c(po.theta, theta_0)
po.delta <- c(po.delta, delta_0)
po.ksi <- c(po.ksi, ksi_0)
set.seed(42)
for (i in 1:m) {
ksi_prime <- rgamma(1, (1+nu)/2, rate = 1 + ((po.theta[i]-theta0)^2) / (nu*po.delta[i]))
theta_prime <- rnorm(1, (nu*mean(df) + 2*theta0*ksi_prime) / (nu+2*ksi_prime), sqrt((nu*po.delta[i]) / (nu+2*ksi_prime)))
delta_rate = (((nu + 2*ksi_prime)*((theta_prime - (nu*mean(df) + 2*ksi_prime*theta0) / (nu + 2*ksi_prime))^2))/(2*nu))+(1/2)*(nu0*s02+(length(df)-1)*var(df)+(2*ksi_prime*(mean(df)-theta0)^2)/(nu+2*ksi_prime))
delta_prime <- rinvgamma(1, (nu0 + length(df) + 1)/2, rate = delta_rate)
po.theta <- c(po.theta, theta_prime)
po.delta <- c(po.delta, delta_prime)
po.ksi <- c(po.ksi, ksi_prime)
}
post_3 <- data.frame(theta = po.theta, delta = po.delta)
post_3 %>% mcmc %>% summary
post_3 %>% mcmc %>% ggs %>% ggs_density()
post_3 %>% mcmc %>% ggs %>% ggs_traceplot()
post_3 %>% mcmc %>% ggs %>% ggs_autocorrelation()
#가능도
df <- c(68.3, 85.7, 73.8, 83.2, 58.9, 72.7, 70.5, 58.7, 74.1, 75.0)
m <- 5000
nu <- length(df) #prior의 정보 1
theta0 <- mean(df) #prior의 정보 2
nu0 <- 1 #prior의 정보 3
s02 <- var(df) #prior의 정보 4
theta_0 <- 0
delta_0 <- 1
ksi_0 <- 0
po.theta = NULL
po.delta = NULL
po.ksi = NULL
po.theta <- c(po.theta, theta_0)
po.delta <- c(po.delta, delta_0)
po.ksi <- c(po.ksi, ksi_0)
set.seed(42)
for (i in 1:m) {
ksi_prime <- rgamma(1, (1+nu)/2, rate = 1 + ((po.theta[i]-theta0)^2) / (nu*po.delta[i]))
theta_prime <- rnorm(1, (nu*mean(df) + 2*theta0*ksi_prime) / (nu+2*ksi_prime), sqrt((nu*po.delta[i]) / (nu+2*ksi_prime)))
delta_rate = (((nu + 2*ksi_prime)*((theta_prime - (nu*mean(df) + 2*ksi_prime*theta0) / (nu + 2*ksi_prime))^2))/(2*nu))+(1/2)*(nu0*s02+(length(df)-1)*var(df)+(2*ksi_prime*(mean(df)-theta0)^2)/(nu+2*ksi_prime))
delta_prime <- rinvgamma(1, (nu0 + length(df) + 1)/2, rate = delta_rate)
po.theta <- c(po.theta, theta_prime)
po.delta <- c(po.delta, delta_prime)
po.ksi <- c(po.ksi, ksi_prime)
}
post_3 <- data.frame(theta = po.theta, delta = po.delta)
post_3 %>% mcmc %>% summary
post_3 %>% mcmc %>% ggs %>% ggs_density()
post_3 %>% mcmc %>% ggs %>% ggs_traceplot()
post_3 %>% mcmc %>% ggs %>% ggs_autocorrelation()
post_3 %>% mcmc %>% summary
post_3 %>% mcmc %>% ggs %>% ggs_density()
post_3 %>% mcmc %>% ggs %>% ggs_traceplot()
post_3 %>% mcmc %>% ggs %>% ggs_autocorrelation()
#가능도
df <- c(68.3, 85.7, 73.8, 83.2, 58.9, 72.7, 70.5, 58.7, 74.1, 75.0)
m <- 50000
nu <- length(df) #prior의 정보 1
theta0 <- mean(df) #prior의 정보 2
nu0 <- 1 #prior의 정보 3
s02 <- var(df) #prior의 정보 4
theta_0 <- 0
delta_0 <- 1
ksi_0 <- 0
po.theta = NULL
po.delta = NULL
po.ksi = NULL
po.theta <- c(po.theta, theta_0)
po.delta <- c(po.delta, delta_0)
po.ksi <- c(po.ksi, ksi_0)
set.seed(42)
for (i in 1:m) {
ksi_prime <- rgamma(1, (1+nu)/2, rate = 1 + ((po.theta[i]-theta0)^2) / (nu*po.delta[i]))
theta_prime <- rnorm(1, (nu*mean(df) + 2*theta0*ksi_prime) / (nu+2*ksi_prime), sqrt((nu*po.delta[i]) / (nu+2*ksi_prime)))
delta_rate = (((nu + 2*ksi_prime)*((theta_prime - (nu*mean(df) + 2*ksi_prime*theta0) / (nu + 2*ksi_prime))^2))/(2*nu))+(1/2)*(nu0*s02+(length(df)-1)*var(df)+(2*ksi_prime*(mean(df)-theta0)^2)/(nu+2*ksi_prime))
delta_prime <- rinvgamma(1, (nu0 + length(df) + 1)/2, rate = delta_rate)
po.theta <- c(po.theta, theta_prime)
po.delta <- c(po.delta, delta_prime)
po.ksi <- c(po.ksi, ksi_prime)
}
post_4 <- data.frame(theta = po.theta, delta = po.delta)
post_4 %>% mcmc %>% ggs %>% ggs_traceplot()
post_4 %>% mcmc %>% ggs %>% ggs_autocorrelation()
post_4 %>% mcmc %>% ggs %>% ggs_histogram()
post_4 %>% mcmc %>% ggs %>% ggs_density()
post_4 %>% mcmc %>% summary
sqrt(86.13)
sqrt(46.165)
sqrt(35.27)
sqrt(203.69)
